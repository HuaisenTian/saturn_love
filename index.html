<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saturn - Complex Asteroid Field</title>

    <script src="https://cdnjs.loli.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            color: white;
        }

        /* 3D场景容器 */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #050505 0%, #0b0b10 100%);
        }

        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
            pointer-events: none;
        }

        .glass-panel {
            background: rgba(5, 5, 5, 0.7);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 2px;
            border-left: 2px solid #c5a059;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            max-width: 280px;
        }

        h1 {
            font-weight: 200;
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            color: #e0cda7;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .status-text {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.6;
            font-family: monospace;
        }

        .highlight {
            color: #c5a059;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            right: 40px;
            z-index: 10;
            pointer-events: auto;
        }

        button {
            background: transparent;
            border: 1px solid rgba(197, 160, 89, 0.3);
            color: #c5a059;
            padding: 12px 30px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button:hover {
            background: rgba(197, 160, 89, 0.1);
            border-color: #c5a059;
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            color: #444;
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
    </style>
</head>
<body>

    <video class="input_video" style="display:none"></video>

    <div id="loading">
        正在构建粒子与行星数据...
    </div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>土星</h1>
            <div class="status-text">
                数据流状态: <span id="status-indicator" class="highlight">待机</span>
                <br><br>
                > 开普勒轨道: 运行中<br>
                > 粒子总数: <span id="particle-count-display">80万+</span><br>
                > 碎石带: <span id="asteroid-count">已加载</span>
            </div>
        </div>
    </div>

    <div id="controls">
        <button onclick="toggleFullScreen()">全屏沉浸体验</button>
    </div>

    <div id="canvas-container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size; attribute vec3 customColor; attribute float opacityAttr;
        attribute float orbitSpeed; attribute float isRing; attribute float aRandomId;
        varying vec3 vColor; varying float vDist; varying float vOpacity;
        varying float vScaleFactor; varying float vIsRing;
        uniform float uTime; uniform float uScale; uniform float uRotationX; uniform float uRotationY;
        mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle)); }
        float hash(float n) { return fract(sin(n) * 43758.5453123); }
        void main() {
            float normScaleLOD = clamp((uScale - 0.15) / 2.35, 0.0, 1.0);
            float visibilityThreshold = 0.9 + pow(normScaleLOD, 1.2) * 0.1;
            if (aRandomId > visibilityThreshold) { gl_Position = vec4(0.0); gl_PointSize = 0.0; return; }
            vec3 pos = position;
            if (isRing > 0.5) {
                float angleOffset = uTime * orbitSpeed * 0.2;
                vec2 rotatedXZ = rotate2d(angleOffset) * pos.xz;
                pos.x = rotatedXZ.x; pos.z = rotatedXZ.y;
            } else {
                float bodyAngle = uTime * 0.03;
                vec2 rotatedXZ = rotate2d(bodyAngle) * pos.xz;
                pos.x = rotatedXZ.x; pos.z = rotatedXZ.y;
            }
            float cy = cos(uRotationY); float sy = sin(uRotationY);
            float rx = pos.x * cy - pos.z * sy; float rz2 = pos.x * sy + pos.z * cy;
            pos.x = rx; pos.z = rz2;
            float cx = cos(uRotationX); float sx = sin(uRotationX);
            float ry = pos.y * cx - pos.z * sx; float rz = pos.y * sx + pos.z * cx;
            pos.y = ry; pos.z = rz;
            vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
            float dist = -mvPosition.z; vDist = dist;
            float chaosThreshold = 25.0;
            if (dist < chaosThreshold && dist > 0.1) {
                float chaosIntensity = 1.0 - (dist / chaosThreshold);
                chaosIntensity = pow(chaosIntensity, 3.0);
                float highFreqTime = uTime * 40.0;
                float noiseX = sin(highFreqTime + pos.x * 10.0) * hash(pos.y);
                float noiseY = cos(highFreqTime + pos.y * 10.0) * hash(pos.x);
                float noiseZ = sin(highFreqTime * 0.5) * hash(pos.z);
                vec3 noiseVec = vec3(noiseX, noiseY, noiseZ) * chaosIntensity * 3.0;
                mvPosition.xyz += noiseVec;
            }
            gl_Position = projectionMatrix * mvPosition;
            float pointSize = size * (350.0 / dist);
            pointSize *= 0.55;
            if (isRing < 0.5 && dist < 50.0) { pointSize *= 0.8; }
            gl_PointSize = clamp(pointSize, 0.0, 300.0);
            vColor = customColor; vOpacity = opacityAttr; vScaleFactor = uScale; vIsRing = isRing;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor; varying float vDist; varying float vOpacity;
        varying float vScaleFactor; varying float vIsRing;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            float glow = smoothstep(1.0, 0.4, r);
            float t = clamp((vScaleFactor - 0.15) / 2.35, 0.0, 1.0);
            vec3 deepGold = vec3(0.35, 0.22, 0.05);
            float colorMix = smoothstep(0.1, 0.9, t);
            vec3 baseColor = mix(deepGold, vColor, colorMix);
            float brightness = 0.2 + 1.0 * t;
            float densityAlpha = 0.25 + 0.45 * smoothstep(0.0, 0.5, t);
            vec3 finalColor = baseColor * brightness;
            if (vDist < 40.0) {
                float closeMix = 1.0 - (vDist / 40.0);
                if (vIsRing < 0.5) {
                    vec3 deepTexture = pow(vColor, vec3(1.4)) * 1.5;
                    finalColor = mix(finalColor, deepTexture, closeMix * 0.8);
                } else {
                    finalColor += vec3(0.15, 0.12, 0.1) * closeMix;
                }
            }
            float depthAlpha = 1.0;
            if (vDist < 10.0) depthAlpha = smoothstep(0.0, 10.0, vDist);
            float alpha = glow * vOpacity * densityAlpha * depthAlpha;
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script type="x-shader/x-vertex" id="starVertexShader">
        attribute float size; attribute vec3 customColor; varying vec3 vColor; uniform float uTime;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float dist = -mvPosition.z;
            gl_PointSize = size * (1000.0 / dist);
            gl_PointSize = clamp(gl_PointSize, 1.0, 8.0);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="starFragmentShader">
        varying vec3 vColor; uniform float uTime;
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            float noise = random(gl_FragCoord.xy);
            float twinkle = 0.7 + 0.3 * sin(uTime * 2.0 + noise * 10.0);
            float glow = 1.0 - r; glow = pow(glow, 1.5);
            gl_FragColor = vec4(vColor * twinkle, glow * 0.8);
        }
    </script>

    <script type="x-shader/x-vertex" id="planetVertexShader">
        varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPosition;
        void main() {
            vUv = uv; vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="planetFragmentShader">
        uniform vec3 color1; uniform vec3 color2; uniform float noiseScale;
        uniform vec3 lightDir; uniform float atmosphere;
        varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPosition;
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        float noise(vec2 st) {
            vec2 i = floor(st); vec2 f = fract(st);
            float a = random(i); float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        float fbm(vec2 st) {
            float value = 0.0; float amplitude = 0.5;
            for (int i = 0; i < 5; i++) { value += amplitude * noise(st); st *= 2.0; amplitude *= 0.5; }
            return value;
        }
        void main() {
            float n = fbm(vUv * noiseScale);
            vec3 albedo = mix(color1, color2, n);
            vec3 normal = normalize(vNormal); vec3 light = normalize(lightDir);
            float diff = max(dot(normal, light), 0.05);
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
            vec3 finalColor = albedo * diff + atmosphere * vec3(0.5, 0.6, 1.0) * fresnel;
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        let scene, camera, renderer, particles, stars, nebula;
        let planetGroup;
        let uniforms, starUniforms;

        let asteroidSystemContainer, asteroidTransformGroup;
        let asteroids = [];

        let targetScale = 1.0, targetRotX = 0.4, targetRotY = 0.0;
        let currentScale = 1.0, currentRotX = 0.4, currentRotY = 0.0;

        let isHandDetected = false;

        // 鼠标控制变量
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isMouseActive = false;
        let mouseTimer = null;

        class GestureSmoother {
            constructor(smoothFactor = 0.6, historySize = 3) {
                this.smoothFactor = smoothFactor;
                this.historySize = historySize;
                this.previousLandmarks = null;
                this.zoomHistory = [];
                this.rotationXHistory = [];
                this.rotationYHistory = [];
            }
            smoothLandmarks(currentLandmarks) {
                if (!currentLandmarks) return null;
                if (!this.previousLandmarks) {
                    this.previousLandmarks = currentLandmarks.map(lm => ({...lm}));
                    return currentLandmarks;
                }
                const smoothed = currentLandmarks.map((curr, i) => {
                    const prev = this.previousLandmarks[i];
                    return {
                        x: prev.x * (1 - this.smoothFactor) + curr.x * this.smoothFactor,
                        y: prev.y * (1 - this.smoothFactor) + curr.y * this.smoothFactor,
                        z: prev.z * (1 - this.smoothFactor) + curr.z * this.smoothFactor
                    };
                });
                this.previousLandmarks = smoothed;
                return smoothed;
            }
            smoothGestureParams(currentGestureInfo) {
                if (!currentGestureInfo) return currentGestureInfo;
                this.zoomHistory.push(currentGestureInfo.zoom);
                if (this.zoomHistory.length > this.historySize) this.zoomHistory.shift();
                const weightedZoom = this.calculateWeightedAverage(this.zoomHistory);

                this.rotationXHistory.push(currentGestureInfo.rotationX);
                if (this.rotationXHistory.length > this.historySize) this.rotationXHistory.shift();
                const weightedRotX = this.calculateWeightedAverage(this.rotationXHistory);

                this.rotationYHistory.push(currentGestureInfo.rotationY);
                if (this.rotationYHistory.length > this.historySize) this.rotationYHistory.shift();
                const weightedRotY = this.calculateWeightedAverage(this.rotationYHistory);

                return { zoom: weightedZoom, rotationX: weightedRotX, rotationY: weightedRotY };
            }
            calculateWeightedAverage(values) {
                if (values.length === 0) return 0;
                if (values.length === 1) return values[0];
                let totalWeight = 0, weightedSum = 0;
                const maxWeight = values.length;
                totalWeight = maxWeight * (maxWeight + 1) / 2;
                for (let i = 0; i < values.length; i++) { weightedSum += values[i] * (i + 1); }
                return weightedSum / totalWeight;
            }
            reset() {
                this.previousLandmarks = null; this.zoomHistory = []; this.rotationXHistory = []; this.rotationYHistory = [];
            }
        }

        const gestureSmoother = new GestureSmoother(0.6, 5);
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status-indicator');
        const loadingElement = document.getElementById('loading');

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.00015);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);

            initSaturn();
            initStarfield();
            initPlanets();
            initAsteroids();

            renderer = new THREE.WebGLRenderer({
                antialias: true, alpha: true,
                powerPreference: "high-performance", preserveDrawingBuffer: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            // 加入鼠标事件监听
            container.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                isMouseActive = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                clearTimeout(mouseTimer);
            });

            window.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                targetRotY += deltaX * 0.005;
                targetRotX += deltaY * 0.005;
                targetRotX = Math.max(-1.5, Math.min(1.5, targetRotX));

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            window.addEventListener('mouseup', () => {
                isMouseDown = false;
                mouseTimer = setTimeout(() => { isMouseActive = false; }, 3000);
            });

            container.addEventListener('wheel', (e) => {
                isMouseActive = true;
                targetScale -= e.deltaY * 0.001;
                targetScale = Math.max(0.15, Math.min(2.5, targetScale));
                clearTimeout(mouseTimer);
                mouseTimer = setTimeout(() => { isMouseActive = false; }, 3000);
            }, { passive: true });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        function formatNumber(num) {
            if (num >= 10000) return (num / 10000).toFixed(1).replace(/\.0$/, '') + '万';
            return num.toString();
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = "rgba(197, 160, 89, 1.0)"; ctx.shadowBlur = 20;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            return new THREE.CanvasTexture(canvas);
        }

        // ==========================================================
        //  主要修改：initAsteroids - 增加形态复杂度和轨道逻辑
        // ==========================================================
        function initAsteroids() {
            asteroidSystemContainer = new THREE.Group();
            asteroidSystemContainer.rotation.z = 26.73 * (Math.PI / 180);
            scene.add(asteroidSystemContainer);

            asteroidTransformGroup = new THREE.Group();
            asteroidTransformGroup.rotation.order = 'YXZ';
            asteroidSystemContainer.add(asteroidTransformGroup);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(100, 50, 100);
            scene.add(sunLight);
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // 1. 特殊命名小行星 (降低基础速度)
            const namedAsteroids = [
                { text: "huaisen", radius: 32, baseSpeed: 0.008, size: 0.22, angle: 0 },
                { text: "peiyue", radius: 38, baseSpeed: 0.006, size: 0.18, angle: Math.PI }
            ];

            // 2. 背景碎石 (增加数量到 160)
            const extraCount = 160;
            const allAsteroids = [...namedAsteroids];
            for(let i=0; i<extraCount; i++) {
                allAsteroids.push({
                    text: null,
                    radius: 24 + Math.random() * 35,
                    baseSpeed: 0.002 + Math.random() * 0.006,
                    size: 0.04 + Math.random() * 0.14,
                    angle: Math.random() * Math.PI * 2,
                    // 将范围改为 0-4，对应下面 5 种更复杂的几何体逻辑
                    shapeIdx: Math.floor(Math.random() * 5)
                });
            }

            document.getElementById('asteroid-count').textContent = `2 + ${extraCount} (多维轨道)`;

            allAsteroids.forEach(data => {
                let geometry;

                if (data.text) {
                    // 命名行星保持稍微圆润的十二面体
                    geometry = new THREE.DodecahedronGeometry(data.size, 0);
                } else {
                    // 背景碎石：去除四面体，增加细分度(detail)使形状更碎裂、复杂
                    if (data.shapeIdx === 0) {
                        // 二十面体 (原始形态)
                        geometry = new THREE.IcosahedronGeometry(data.size, 0);
                    } else if (data.shapeIdx === 1) {
                        // 二十面体 (增加 1 级细分，产生更多碎裂面，看起来像更复杂的矿石)
                        geometry = new THREE.IcosahedronGeometry(data.size, 1);
                    } else if (data.shapeIdx === 2) {
                        // 十二面体 (增加 1 级细分)
                        geometry = new THREE.DodecahedronGeometry(data.size, 1);
                    } else if (data.shapeIdx === 3) {
                        // 八面体 (增加 1 级细分)
                        geometry = new THREE.OctahedronGeometry(data.size, 1);
                    } else {
                        // 低段数球体：(由于非均匀缩放，会产生像鹅卵石或陨石核心的平滑不规则形状)
                        geometry = new THREE.SphereGeometry(data.size, 5, 4);
                    }
                }

                // 提示：下方的 mesh.scale.set 非均匀缩放逻辑请务必保留，
                // 它是让这些复杂几何体真正变成“岩石”而不只是“数学多面体”的关键。
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.08, 0.15, 0.35 + Math.random() * 0.4),
                    flatShading: true // 开启平面着色，增强岩石的棱角感
                });

                const mesh = new THREE.Mesh(geometry, material);

                // --- 复杂形态核心：应用非均匀缩放使其呈现岩石块状 ---
                if (!data.text) {
                    mesh.scale.set(
                        0.7 + Math.random() * 0.9,
                        0.7 + Math.random() * 0.9,
                        0.7 + Math.random() * 0.9
                    );
                }

                if (data.text) {
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                        map: createTextTexture(data.text), transparent: true, depthTest: false
                    }));
                    sprite.scale.set(8, 4, 1);
                    sprite.position.y = data.size * 3.5;
                    mesh.add(sprite);
                }

                mesh.userData = {
                    semiMajorAxis: data.radius * (1.0 + Math.random() * 0.2),
                    semiMinorAxis: data.radius * (0.8 + Math.random() * 0.2),
                    orbitSpeed: data.baseSpeed,
                    currentAngle: data.angle,
                    // 轨道倾角：不再只是平面，而是有随机倾斜角度
                    inclination: (Math.random() - 0.5) * 0.4,
                    rotSpeedX: 0.001 + Math.random() * 0.005,
                    rotSpeedY: 0.001 + Math.random() * 0.005,
                    wobbleSpeed: 0.5 + Math.random() * 1.5,
                    wobbleHeight: (Math.random() - 0.5) * 2.5,
                    yOffset: (Math.random() - 0.5) * 2.0
                };

                asteroidTransformGroup.add(mesh);
                asteroids.push(mesh);
            });
        }

        function initSaturn() {
            const particleCount = 800000;
            const particleCountDisplay = document.getElementById('particle-count-display');
            if (particleCountDisplay) particleCountDisplay.textContent = formatNumber(particleCount) + '+';
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const opacities = new Float32Array(particleCount);
            const orbitSpeeds = new Float32Array(particleCount);
            const isRings = new Float32Array(particleCount);
            const randomIds = new Float32Array(particleCount);
            const bodyColors = [new THREE.Color('#E3DAC5'), new THREE.Color('#C9A070'), new THREE.Color('#E3DAC5'), new THREE.Color('#B08D55')];
            const colorRingC = new THREE.Color('#2A2520'); const colorRingB_Inner = new THREE.Color('#CDBFA0');
            const colorRingB_Outer = new THREE.Color('#DCCBBA'); const colorCassini = new THREE.Color('#050505');
            const colorRingA = new THREE.Color('#989085'); const colorRingF = new THREE.Color('#AFAFA0');
            const R_PLANET = 18;
            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b, size, opacity, speed, isRingVal;
                randomIds[i] = Math.random();
                if (i < particleCount * 0.25) {
                    isRingVal = 0.0; speed = 0.0;
                    const u = Math.random(); const v = Math.random();
                    const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                    const rad = R_PLANET;
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    let rawY = rad * Math.cos(phi);
                    z = rad * Math.sin(phi) * Math.sin(theta);
                    y = rawY * 0.9;
                    let lat = (rawY / rad + 1.0) * 0.5;
                    let bandNoise = Math.cos(lat * 40.0) * 0.8 + Math.cos(lat * 15.0) * 0.4;
                    let colIndex = Math.floor(lat * 4 + bandNoise) % 4;
                    if (colIndex < 0) colIndex = 0;
                    let baseCol = bodyColors[colIndex];
                    r = baseCol.r; g = baseCol.g; b = baseCol.b;
                    size = 1.0 + Math.random() * 0.8; opacity = 0.8;
                } else {
                    isRingVal = 1.0;
                    let zoneRand = Math.random(); let ringRadius; let ringCol;
                    if (zoneRand < 0.15) { ringRadius = R_PLANET * (1.235 + Math.random() * (1.525 - 1.235)); ringCol = colorRingC; size = 0.5; opacity = 0.3; }
                    else if (zoneRand < 0.65) { let t = Math.random(); ringRadius = R_PLANET * (1.525 + t * (1.95 - 1.525)); ringCol = colorRingB_Inner.clone().lerp(colorRingB_Outer, t); size = 0.8 + Math.random() * 0.6; opacity = 0.85; if (Math.sin(ringRadius * 2.0) > 0.8) opacity *= 1.2; }
                    else if (zoneRand < 0.69) { ringRadius = R_PLANET * (1.95 + Math.random() * (2.025 - 1.95)); ringCol = colorCassini; size = 0.3; opacity = 0.1; }
                    else if (zoneRand < 0.99) { ringRadius = R_PLANET * (2.025 + Math.random() * (2.27 - 2.025)); ringCol = colorRingA; size = 0.7; opacity = 0.6; if (ringRadius > R_PLANET * 2.2 && ringRadius < R_PLANET * 2.21) opacity = 0.1; }
                    else { ringRadius = R_PLANET * (2.32 + Math.random() * 0.02); ringCol = colorRingF; size = 1.0; opacity = 0.7; }
                    const theta = Math.random() * Math.PI * 2;
                    x = ringRadius * Math.cos(theta); z = ringRadius * Math.sin(theta);
                    let thickness = 0.15; if (ringRadius > R_PLANET * 2.3) thickness = 0.4;
                    y = (Math.random() - 0.5) * thickness;
                    r = ringCol.r; g = ringCol.g; b = ringCol.b;
                    speed = 8.0 / Math.sqrt(ringRadius);
                }
                positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                colors[i*3] = r; colors[i*3+1] = g; colors[i*3+2] = b;
                sizes[i] = size; opacities[i] = opacity;
                orbitSpeeds[i] = speed; isRings[i] = isRingVal;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(opacities, 1));
            geometry.setAttribute('orbitSpeed', new THREE.BufferAttribute(orbitSpeeds, 1));
            geometry.setAttribute('isRing', new THREE.BufferAttribute(isRings, 1));
            geometry.setAttribute('aRandomId', new THREE.BufferAttribute(randomIds, 1));
            uniforms = { uTime: { value: 0 }, uScale: { value: 1.0 }, uRotationX: { value: 0.4 }, uRotationY: { value: 0.0 } };
            const material = new THREE.ShaderMaterial({
                depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true, uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent, transparent: true
            });
            particles = new THREE.Points(geometry, material);
            particles.rotation.z = 26.73 * (Math.PI / 180);
            scene.add(particles);
        }

        function initStarfield() {
            const starCount = 50000; const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(starCount * 3); const cols = new Float32Array(starCount * 3); const sizes = new Float32Array(starCount);
            const starColors = [new THREE.Color('#9bb0ff'), new THREE.Color('#ffffff'), new THREE.Color('#ffcc6f'), new THREE.Color('#ff7b7b')];
            for(let i=0; i<starCount; i++) {
                const r = 400 + Math.random() * 3000; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                pos[i*3] = r * Math.sin(phi) * Math.cos(theta); pos[i*3+1] = r * Math.cos(phi); pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                const colorType = Math.random(); let c;
                if(colorType > 0.9) c = starColors[0]; else if(colorType > 0.6) c = starColors[1]; else if(colorType > 0.3) c = starColors[2]; else c = starColors[3];
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b; sizes[i] = 1.0 + Math.random() * 3.0;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3)); geo.setAttribute('customColor', new THREE.BufferAttribute(cols, 3)); geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            starUniforms = { uTime: { value: 0 } };
            const mat = new THREE.ShaderMaterial({
                uniforms: starUniforms, vertexShader: document.getElementById('starVertexShader').textContent, fragmentShader: document.getElementById('starFragmentShader').textContent,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            stars = new THREE.Points(geo, mat); scene.add(stars);
            const nebulaCount = 100; const nebGeo = new THREE.BufferGeometry();
            const nebPos = new Float32Array(nebulaCount * 3); const nebCols = new Float32Array(nebulaCount * 3); const nebSizes = new Float32Array(nebulaCount);
            for(let i=0; i<nebulaCount; i++) {
                const r = 800 + Math.random() * 2000; const theta = Math.random() * Math.PI * 2; const phi = Math.PI / 2 + (Math.random() - 0.5) * 1.5;
                nebPos[i*3] = r * Math.sin(phi) * Math.cos(theta); nebPos[i*3+1] = r * Math.cos(phi); nebPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                const nc = new THREE.Color().setHSL(0.6 + Math.random()*0.2, 0.8, 0.05);
                nebCols[i*3] = nc.r; nebCols[i*3+1] = nc.g; nebCols[i*3+2] = nc.b; nebSizes[i] = 400.0 + Math.random() * 600.0;
            }
            nebGeo.setAttribute('position', new THREE.BufferAttribute(nebPos, 3)); nebGeo.setAttribute('customColor', new THREE.BufferAttribute(nebCols, 3)); nebGeo.setAttribute('size', new THREE.BufferAttribute(nebSizes, 1));
            const nebShaderMat = new THREE.ShaderMaterial({
                uniforms: {}, vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: `varying vec3 vColor; void main() { vec2 cxy = 2.0 * gl_PointCoord - 1.0; float r = dot(cxy, cxy); if(r > 1.0) discard; float glow = pow(1.0 - r, 2.0); gl_FragColor = vec4(vColor, glow * 0.1); }`,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            nebula = new THREE.Points(nebGeo, nebShaderMat); scene.add(nebula);
        }

        function initPlanets() {
            planetGroup = new THREE.Group(); scene.add(planetGroup);
            const vShader = document.getElementById('planetVertexShader').textContent; const fShader = document.getElementById('planetFragmentShader').textContent;
            createPlanet(planetGroup, vShader, fShader, new THREE.Color('#b33a00'), new THREE.Color('#d16830'), 8.0, { x: -300, y: 120, z: -450 }, 10, 0.3);
            createPlanet(planetGroup, vShader, fShader, new THREE.Color('#001e4d'), new THREE.Color('#ffffff'), 5.0, { x: 380, y: -100, z: -600 }, 14, 0.6);
            createPlanet(planetGroup, vShader, fShader, new THREE.Color('#666666'), new THREE.Color('#aaaaaa'), 15.0, { x: -180, y: -220, z: -350 }, 6, 0.1);
        }

        function createPlanet(group, vShader, fShader, c1, c2, nScale, pos, radius, atmo) {
            const geo = new THREE.SphereGeometry(radius, 48, 48);
            const mat = new THREE.ShaderMaterial({
                uniforms: { color1: { value: c1 }, color2: { value: c2 }, noiseScale: { value: nScale }, lightDir: { value: new THREE.Vector3(1, 0.5, 1) }, atmosphere: { value: atmo } },
                vertexShader: vShader, fragmentShader: fShader
            });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(pos.x, pos.y, pos.z); group.add(mesh);
        }

        const clock = new THREE.Clock();
        let autoIdleTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            uniforms.uTime.value = elapsedTime;
            if(starUniforms) starUniforms.uTime.value = elapsedTime;

            if(stars) stars.rotation.y = elapsedTime * 0.005;
            if(nebula) nebula.rotation.y = elapsedTime * 0.003;

            if(planetGroup) {
                planetGroup.children.forEach((planet, idx) => { planet.rotation.y = elapsedTime * (0.05 + idx * 0.02); });
                planetGroup.rotation.y = Math.sin(elapsedTime * 0.05) * 0.02;
            }

            let lerpFactor = 0.05;
            if (!isHandDetected && !isMouseActive) {
                lerpFactor = 0.01;
                autoIdleTime += 0.005;
                if(autoIdleTime > 20 * Math.PI) autoIdleTime = 0;
                targetScale = 1.0 + Math.sin(autoIdleTime) * 0.1;
                targetRotX = 0.4 + Math.sin(autoIdleTime * 0.3) * 0.15;
                statusElement.innerHTML = "系统状态: 自动巡航<br>输入信号: 等待中...";
                statusElement.style.color = "#666";
            } else {
                lerpFactor = 0.15;
                const source = isHandDetected ? "视觉控制" : "鼠标控制";
                statusElement.innerHTML = `系统状态: 手动接管<br>输入信号: <span class='highlight'>${source}已锁定</span>`;
                statusElement.style.color = "#c5a059";
            }

            currentScale += (targetScale - currentScale) * lerpFactor;
            currentRotX += (targetRotX - currentRotX) * lerpFactor;
            currentRotY += (targetRotY - currentRotY) * lerpFactor;

            uniforms.uScale.value = currentScale;
            uniforms.uRotationX.value = currentRotX;
            uniforms.uRotationY.value = currentRotY;

            if (asteroidTransformGroup) {
                asteroidTransformGroup.scale.set(currentScale, currentScale, currentScale);
                asteroidTransformGroup.rotation.x = currentRotX;
                asteroidTransformGroup.rotation.y = currentRotY;
            }

            // 更新小行星逻辑 (包含复杂轨迹计算)
            if (asteroids.length > 0) {
                asteroids.forEach(mesh => {
                    const data = mesh.userData;
                    data.currentAngle += data.orbitSpeed * 0.01;

                    // 计算基础椭圆坐标
                    const xBase = Math.cos(data.currentAngle) * data.semiMajorAxis;
                    const zBase = Math.sin(data.currentAngle) * data.semiMinorAxis;

                    // --- 复杂轨迹修改：引入轨道倾角计算 ---
                    mesh.position.x = xBase;
                    mesh.position.z = zBase;

                    // Y坐标 = 基础偏移 + 垂直波动频率 + 轨道倾角带来的高度差
                    const orbitInclinationY = xBase * data.inclination;
                    mesh.position.y = data.yOffset + orbitInclinationY + Math.sin(data.currentAngle * data.wobbleSpeed) * data.wobbleHeight;

                    // 自转更新
                    mesh.rotation.x += data.rotSpeedX;
                    mesh.rotation.y += data.rotSpeedY;
                });
            }

            renderer.render(scene, camera);
        }

        const hands = new Hands({locateFile: (file) => `https://fastly.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        function onResults(results) {
            loadingElement.style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const rawHand = results.multiHandLandmarks[0];
                const smoothedHand = gestureSmoother.smoothLandmarks(rawHand);
                const p1 = smoothedHand[4]; const p2 = smoothedHand[8];
                const dist = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);

                const normDist = Math.max(0, Math.min(1, (dist - 0.02) / 0.25));
                const hScale = 0.15 + normDist * 2.35;
                const y = smoothedHand[9].y; const normY = Math.max(0, Math.min(1, (y - 0.1) / 0.8));
                const hRotX = -0.6 + normY * 1.6;
                const x = smoothedHand[9].x; const normX = Math.max(0, Math.min(1, (x - 0.1) / 0.7));
                const hRotY = -Math.PI/2 + normX * Math.PI;

                const smoothedParams = gestureSmoother.smoothGestureParams({ zoom: hScale, rotationX: hRotX, rotationY: hRotY });
                targetScale = smoothedParams.zoom; targetRotX = smoothedParams.rotationX; targetRotY = smoothedParams.rotationY;
            } else {
                isHandDetected = false; gestureSmoother.reset();
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().catch(e => { console.error(e); loadingElement.innerText = "摄像头启动失败"; });

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        initThree();
    </script>
</body>
</html>
